
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Welcome to PyPlaneGeometry’s documentation! &#8212; PyPlaneGeometry 0.1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" href="_static/css/function.css" type="text/css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="welcome-to-pyplanegeometrys-documentation">
<h1>Welcome to PyPlaneGeometry’s documentation!<a class="headerlink" href="#welcome-to-pyplanegeometrys-documentation" title="Permalink to this headline">¶</a></h1>
</section>
<section id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference external" href="genindex.rst">Index</a></p></li>
<li><p><a class="reference external" href="py-modindex.rst">Module Index</a></p></li>
<li><p><a class="reference external" href="search.rst">Search Page</a></p></li>
</ul>
<p><strong>class planegeometry.geometry.Affine(A, b)</strong></p>
<blockquote>
<div><p>A class for affine transformations.</p>
<p>An affine transformation is initialized by a 2x2 matrix (a linear
transformation),  and a length two vector (the ‘intercept’, an
array-like object).</p>
<p><strong>compose(transfo, left=True)</strong></p>
<blockquote>
<div><p>Compose the reference affine map with another affine map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>transfo</strong> – an <em>Affine</em> object</p></li>
<li><p><strong>left</strong> – Boolean, whether to compose at left or at right
(i.e. returns <em>f1 o f0</em> or <em>f0 o f1</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Affine</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_ellipse_to_ellipse(ell1, ell2)</strong></p>
<blockquote>
<div><p>Affine transformation mapping a given ellipse to a given
ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ell1**</strong>,****ell2** – <em>Ellipse</em> or <em>Circle</em> objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Affine</em> object representing the transformation which maps
<em>ell1</em> to <em>ell2</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_mapping_three_points(P1, P2, P3, Q1, Q2, Q3)</strong></p>
<blockquote>
<div><p>Affine transformation mapping three given points to three given
points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P1**</strong>,****P2****,****P3** – three non-collinear points</p></li>
<li><p><strong>Q1**</strong>,****Q2****,****Q3** – three non-collinear points</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Affine</em> object representing the transformation which maps
Pi to Qi for each i=1,2,3.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Get the 3x3 matrix corresponding to the affine transformation.</p>
</div></blockquote>
<p><strong>inverse()</strong></p>
<blockquote>
<div><p>The inverse affine transformation if it exists.</p>
</div></blockquote>
<p><strong>transform(m)</strong></p>
<blockquote>
<div><p>Transform a point or several points by the affine map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>m</strong> – a point or a two-column matrix of points, one point
per row</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A matrix or a vector.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform_ellipse(ell)</strong></p>
<blockquote>
<div><p>Transform an ellipse by the reference affine transformation
(only for an invertible affine map).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ell</strong> – an <em>Ellipse</em> object or a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform_line(line)</strong></p>
<blockquote>
<div><p>Transform a line by the affine map.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Arc(center, radius, alpha1, alpha2,
degrees=True)</strong></p>
<blockquote>
<div><p>Arc class.</p>
<p>A circular arc is initialized by its center (array-like object of
length  two), a radius, a starting angle and an ending angle. They
are  respectively named <em>center</em>, <em>radius</em>, <em>alpha1</em> and <em>alpha2</em>.</p>
<p><strong>ending_point()</strong></p>
<blockquote>
<div><p>Ending point of the arc.</p>
</div></blockquote>
<p><strong>path(n_points=100)</strong></p>
<blockquote>
<div><p>Path that forms the arc.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_points</strong> – number of points of the path</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A matrix with two columns and <em>n_points</em> rows.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>starting_point()</strong></p>
<blockquote>
<div><p>Starting point of the arc.</p>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Circle(center, radius)</strong></p>
<blockquote>
<div><p>A class for circles. A circle is given by its center and its
radius.</p>
<p><strong>angle(circ2)</strong></p>
<blockquote>
<div><p>Angle between the reference circle and a given circle, if they
intersect.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ2</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The angle in radians.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>as_ellipse()</strong></p>
<blockquote>
<div><p>Converts the circle to an <em>Ellipse</em> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>contains(P)</strong></p>
<blockquote>
<div><p>Check whether a point is contained in the reference circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>includes(P)</strong></p>
<blockquote>
<div><p>Check whether a point belongs to the reference circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>intersection_with_circle(circ2)</strong></p>
<blockquote>
<div><p>Intersection(s) of the reference circle with another circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ2</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em> (no intersection), a point (the two circles are
tangent), or two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>intersection_with_line(line)</strong></p>
<blockquote>
<div><p>Intersection(s) of the reference circle with a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em> (no intersection), a point (the line is tangent to the
circle), or two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>is_equal(circ2)</strong></p>
<blockquote>
<div><p>Check whether the reference circle is equal to another circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ2</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>is_orthogonal(circ2)</strong></p>
<blockquote>
<div><p>Check whether the reference circle is orthogonal to a given
circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ2</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>orthogonal_through_two_points_in_circle(P1, P2, arc=False)</strong></p>
<blockquote>
<div><p>Orthogonal circle passing through two points within the
reference circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P1**</strong>,****P2** – two distinct points in the interior of
the reference circle</p></li>
<li><p><strong>arc</strong> – Boolean, whether to return the arc joining the
two points instead of the circle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object or an <em>Arc</em> object, or a <em>Line</em> object if
the two points are on a diameter.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>orthogonal_through_two_points_on_circle(alpha1, alpha2,
arc=False)</strong></p>
<blockquote>
<div><p>Orthogonal circle passing through two points on the reference
circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha1**</strong>,****alpha2** – two angles defining two points
on the reference circle</p></li>
<li><p><strong>arc</strong> – Boolean, whether to return only the arc at the
interior of the reference circle</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object if <em>arc=False</em>, an <em>Arc</em> object if
<em>arc=True, or a `Line</em> object: the diameter of the reference
circle defined by the two points in case when the two angles
differ by <em>pi</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>point_from_angle(alpha, degrees=True)</strong></p>
<blockquote>
<div><p>Get a point on the reference circle from its polar angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> – a number, the angle</p></li>
<li><p><strong>degrees</strong> – Boolean, whether the angle is given in
degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The point on the circle with polar angle <em>alpha</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>power(M)</strong></p>
<blockquote>
<div><p>Power of a point with respect to the reference circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point (array-like of length two)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A number, the power of <em>M</em> with respect to the circle.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>radical_axis(circ2)</strong></p>
<blockquote>
<div><p>Radical axis of two circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ2</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object, the radical axis of the reference circle and
<em>circ2</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>radical_center(circ2)</strong></p>
<blockquote>
<div><p>Radical center of two circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ2</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The radical center of the reference circle and <em>circ2</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>random_points(n_points, where=’in’)</strong></p>
<blockquote>
<div><p>Random points in the circle or on the circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_points</strong> – desired number of points</p></li>
<li><p><strong>where</strong> – either <em>“in”</em> or <em>“on”</em></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A matrix with <em>n_points</em> rows and two columns; each row is a
random point inside the circle if <em>where=”in”</em> or on the
boundary of the circle if <em>where=”on”</em>.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Ellipse(center, rmajor, rminor, alpha,
degrees=True)</strong></p>
<blockquote>
<div><p>Ellipse class.</p>
<p>An ellipse is initialized by its center (array-like object of
length two),  its major radius, its minor radius, and the angle
<em>alpha</em> between the  x-axis and the major axis.</p>
<p><strong>classmethod LownerJohnEllipse(ipoints, bpoints=None)</strong></p>
<blockquote>
<div><p>Minimum area ellipse containing a set of points (ellipse hull).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ipoints</strong> – an array of shape (n,2) containing points as
row vectors, which are inside the desired ellipse; it must
have at  least three distinct rows</p></li>
<li><p><strong>bpoints</strong> – an array of shape (n,2) containing points as
row vectors, which are on the boundary of the desired
ellipse;  could be <em>None</em> (the default)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object, the Löwner-John ellipse.</p>
</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Dor Shaviv</p>
</dd>
</dl>
</div></blockquote>
<p><strong>contains(P)</strong></p>
<blockquote>
<div><p>Check whether a point is contained in the ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>equation()</strong></p>
<blockquote>
<div><p>The coefficients of the implicit equation of the ellipse,  <em>Ax²
+ Bxy + Cy² + Dx + Ey + F = 0</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dictionary giving the values of the coefficients.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod equation_from_five_points(P1, P2, P3, P4, P5)</strong></p>
<blockquote>
<div><p>The implicit equation of the ellipse is <em>Ax² + Bxy + Cy² + Dx +
Ey + F = 0</em>. This function returns A, B, C, D, E and F.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P1**</strong>,****P2****,****P3****,****P4****,****P5** – five
points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A dictionary giving A, B, C, D, E and F.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_boundary3(points)</strong></p>
<blockquote>
<div><p>Compute the smallest ellipse that passes through 3 boundary
points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – an array of shape (3,2) containing points as row
vectors, which are on the boundary of the desired ellipse.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object.</p>
</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Dor Shaviv</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_boundary4(points)</strong></p>
<blockquote>
<div><p>Compute the smallest ellipse that passes through 4 boundary
points, based on the algorithm by: B. W. Silverman and D. M.
Titterington, “Minimum covering ellipses,” SIAM Journal on
Scientific and Statistical Computing 1, no. 4 (1980): 401-409.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>points</strong> – an array of shape (4,2) containing points as row
vectors, which are on the boundary of the desired ellipse.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object.</p>
</dd>
<dt class="field-odd">Author</dt>
<dd class="field-odd"><p>Dor Shaviv</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_center_and_matrix(center, S)</strong></p>
<p><strong>classmethod from_equation(A, B, C, D, E, F)</strong></p>
<blockquote>
<div><p>Ellipse from its implicit equation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A**</strong>,****B****,****C****,****D****,****E****,****F** –
coefficients of the implicit equation of the ellipse</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_five_points(P1, P2, P3, P4, P5)</strong></p>
<blockquote>
<div><p>Ellipse from five points on this ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P1**</strong>,****P2****,****P3****,****P4****,****P5** – five
points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>includes(P)</strong></p>
<blockquote>
<div><p>Check whether a point belongs to the ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>intersection_with_line(line)</strong></p>
<p><strong>is_equal(ell2)</strong></p>
<blockquote>
<div><p>Check whether the reference ellipse equals another ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ell2</strong> – an <em>Ellipse</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>normal(t)</strong></p>
<blockquote>
<div><p>Normal unit vector to the ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> – a number, the eccentric angle in radians of the point
of the ellipse at which we want the normal unit vector</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The normal unit vector to the ellipse at the point given by
eccentric angle <em>t</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>path(n_points=100)</strong></p>
<blockquote>
<div><p>Path that forms the ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_points</strong> – number of points of the path</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A matrix with two columns and <em>n_points</em> rows.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>point_from_angle(theta, degrees=True)</strong></p>
<p><strong>random_points(n_points, where=’in’)</strong></p>
<blockquote>
<div><p>Random points in/on the ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_points</strong> – desired number of points</p></li>
<li><p><strong>where</strong> – either <em>“in”</em> or <em>“on”</em></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A matrix with <em>n_points</em> rows and two columns; each row is a
random point inside the ellipse if <em>where=”in”</em> or on the
boundary of the ellipse if <em>where=”on”</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>shape_matrix()</strong></p>
<blockquote>
<div><p>The 2x2 symmetric matrix <em>S</em> associated to the reference
ellipse.  The equation of the ellipse is <em>(M-O)’ S (M-O) = 1</em>.</p>
</div></blockquote>
<p><strong>theta2t(theta, degrees=True)</strong></p>
<blockquote>
<div><p>Convert angle to eccentric angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>theta</strong> – angle between the major axis and the half-line
starting at the center of the ellipse and passing through
the point of interest on the ellipse</p></li>
<li><p><strong>degrees</strong> – Boolean, whether <em>theta</em> is given in degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The eccentric angle of the point of interest on the ellipse,
in radians.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Homothety(center, scale)</strong></p>
<blockquote>
<div><p>A homothety is given by a center and a scale factor.</p>
<p><strong>as_affine()</strong></p>
<blockquote>
<div><p>Converting to an <em>Affine</em> object.</p>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Get the augmented matrix of the homothety.</p>
</div></blockquote>
<p><strong>transform(M)</strong></p>
<blockquote>
<div><p>Transform one or more points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point or a matrix of points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point or a matrix of points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform_circle(circ)</strong></p>
<blockquote>
<div><p>Transform a circle by the homothety.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Inversion(pole, power)</strong></p>
<blockquote>
<div><p>Inversion class.</p>
<p>An inversion is initialized by its pole and its power (a number,
possibly negative).</p>
<p><strong>compose(iota2, left=True)</strong></p>
<blockquote>
<div><p>Compose the reference inversion with another inversion. The
result  is a Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iota2</strong> – an <em>Inversion</em> object</p></li>
<li><p><strong>left</strong> – Boolean, whether to compose at left or at right
(i.e. returns <em>iota2 o iota1</em> or <em>iota1 o iota2</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Mobius</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_fixing_three_circles(circ1, circ2, circ3)</strong></p>
<blockquote>
<div><p>Inversion fixing three circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ1**</strong>,****circ2****,****circ3** – <em>Circle</em> objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Inversion</em> object representing an inversion which leaves
each of the three circles invariant.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_fixing_two_circles(circ1, circ2)</strong></p>
<blockquote>
<div><p>Inversion fixing two circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ1**</strong>,****circ2** – <em>Circle</em> objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Inversion</em> object representing an inversion which leaves
each of the two circles invariant.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_swapping_two_circles(circ1, circ2,
positive=True)</strong></p>
<blockquote>
<div><p>Inversion swapping two circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>circ1**</strong>,****circ2** – <em>Circle</em> objects</p></li>
<li><p><strong>positive</strong> – Boolean, whether the sign of the desired
inversion power must be positive or negative</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Inversion</em> object, which maps <em>circ1</em> to <em>circ2</em> and
<em>circ2</em> to <em>circ1</em>, except in the case when <em>circ1</em> and
<em>circ2</em> are congruent and tangent: in this case a
<em>Reflection</em> object is returned (a reflection is an inversion
on a line).</p>
</dd>
</dl>
</div></blockquote>
<p><strong>invert_gcircle(gcircle)</strong></p>
<blockquote>
<div><p>Invert a generalized circle, that is, a circle or a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Params gcircle`</dt>
<dd class="field-odd"><p>a <em>Circle</em> object or a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object or a <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod on_circle(circ)</strong></p>
<blockquote>
<div><p>An inversion on a circle is the inversion whose pole is the
center  of the circle and whose power is the squared radius of
the circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ</strong> – <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Inversion</em> object.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Line(A, B, extendA=True,
extendB=True)</strong></p>
<blockquote>
<div><p>A class for lines. A line is initialized by two points it passes
through,  and for each of these points a Boolean value to indicate
whether the line  should be extended besides this point.</p>
<p><strong>direction_offset()</strong></p>
<blockquote>
<div><p>Direction and offset of the line. The equation of the line is
<em>cos(direction)x + sin(direction)y = offset</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The direction and the offset in a dictionary.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>distance(M)</strong></p>
<blockquote>
<div><p>Distance from a point to the reference line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A number.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>includes(M, strict=False, checkCollinear=True)</strong></p>
<blockquote>
<div><p>Check whether a point belongs to the line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> – the point for which we want to test whether it
belongs to the line</p></li>
<li><p><strong>strict</strong> – Boolean, whether to take into account
<em>extendA</em> and <em>extendB</em></p></li>
<li><p><strong>checkCollinear</strong> – Boolean, whether to check the
collinearity of <em>A</em>, <em>B</em>, and <em>M</em>; set to <em>False</em> only if
you use <em>strict=True</em> and you are sure that <em>M</em> is on the
line (AB)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>intersection_with_circle(circ)</strong></p>
<blockquote>
<div><p>Intersection(s) of the line with a circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em>, a point, or a list of two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>intersection_with_ellipse(ell)</strong></p>
<blockquote>
<div><p>Intersection(s) of the line with an ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ell</strong> – an <em>Ellipse</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em>, a point, or a list of two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>intersection_with_line(line2, strict=False)</strong></p>
<blockquote>
<div><p>Intersection(s) of the reference line with another line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line2</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em> (the lines are parallel), a point, or a <em>Line</em> object
(the two lines are equal).</p>
</dd>
</dl>
</div></blockquote>
<p><strong>invert(iota)</strong></p>
<blockquote>
<div><p>Invert the reference line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>iota</strong> – an <em>Inversion.fro</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object or a <em>Circle</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>is_equal(line2)</strong></p>
<blockquote>
<div><p>Check whether the reference line is equal to another line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line2</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>is_parallel(line2)</strong></p>
<blockquote>
<div><p>Check whether the reference line is parallel to another line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line2</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A Boolean value.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>perpendicular(M, extendH=False, extendM=True)</strong></p>
<blockquote>
<div><p>Perpendicular line passing through a given point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M</strong> – the point through which the perpendicular passes</p></li>
<li><p><strong>extendH</strong> – Boolean, whether to extend the perpendicular
line beyond the meeting point</p></li>
<li><p><strong>extendM</strong> – Boolean, whether to extend the perpendicular
line beyond the point <em>M</em></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object; its two points are the meeting point and the
point <em>M</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>projection(M)</strong></p>
<blockquote>
<div><p>Orthogonal projection of a point to the reference line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on the reference line.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>reflection(M)</strong></p>
<blockquote>
<div><p>Reflection of a point with respect to the reference line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>rotate(alpha, O, degrees=True)</strong></p>
<blockquote>
<div><p>Rotate the reference line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>alpha</strong> – angle of rotation</p></li>
<li><p><strong>O</strong> – center of rotation</p></li>
<li><p><strong>degrees</strong> – Boolean, whether <em>alpha</em> is given in degrees</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>translate(v)</strong></p>
<blockquote>
<div><p>Translate the reference line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v</strong> – the vector of translation</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Mobius(M)</strong></p>
<blockquote>
<div><p>A class for Möbius transformations.</p>
<p>A Möbius transformation is initialized by a complex 2x2 matrix with
a   non-zero determinant.</p>
<p><strong>compose(M1, left=True)</strong></p>
<blockquote>
<div><p>Compose the reference Möbius transformation with another Möbius
transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>M1</strong> – a <em>Mobius</em> object</p></li>
<li><p><strong>left</strong> – Boolean, whether to compose at left or at right
(i.e. returns <em>M1 o M0</em> or <em>M0 o M1</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Mobius</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>classmethod from_mapping_three_points(P1, P2, P3, Q1, Q2, Q3)</strong></p>
<blockquote>
<div><p>Möbius transformation mapping three given points to three given
points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>P1**</strong>,****P2****,****P3** – three distinct points,
<em>inf</em> allowed</p></li>
<li><p><strong>Q1**</strong>,****Q2****,****Q3** – three distinct points,
<em>inf</em> allowed</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Mobius</em> object, representing the Möbius transformation
which sends <em>Pi</em> to <em>Qi</em> for each i=1,2,3.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>gpower(t)</strong></p>
<blockquote>
<div><p>Generalized power of the Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>t</strong> – a float, possibly negative</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Mobius</em> object corresponding to the Möbius transformation
raised to the power <em>t</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>inverse()</strong></p>
<blockquote>
<div><p>Inverse of the Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A Möbius transformation.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>power(k)</strong></p>
<blockquote>
<div><p>Power of the Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>k</strong> – an integer, possibly negative</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Mobius</em> object corresponding to the Möbius transformation
raised to the power <em>k</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform(P)</strong></p>
<blockquote>
<div><p>Transform a point by the Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> – a point (array-like of length two) or <em>inf</em></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The image of <em>P</em> by the Möbius transformation (can be <em>inf</em>).</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform_circle(circ)</strong></p>
<blockquote>
<div><p>Transform a circle by the Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object or a <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform_line(line)</strong></p>
<blockquote>
<div><p>Transform a line by the Möbius transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object or a <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Projection(D, Delta)</strong></p>
<blockquote>
<div><p>A class for projections. A projection on a line is given by the
line of  projection <em>D</em> and the directrix line <em>Delta</em>.</p>
<p>For an orthogonal projection, you can also use the <em>projection</em>
method of  the <em>Line</em> class.</p>
<p><strong>as_affine()</strong></p>
<blockquote>
<div><p>Convert the projection to an <em>Affine</em> object.</p>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Augmented matrix of the projection.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A 3x3 matrix.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>project(M)</strong></p>
<blockquote>
<div><p>Projection of a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point on <em>D</em>, the projection of <em>M</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform(M)</strong></p>
<blockquote>
<div><p>An alias of <em>project</em></p>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Reflection(line)</strong></p>
<blockquote>
<div><p>A class for reflections.</p>
<p>A reflection is initialized by a line.</p>
<p><strong>as_affine()</strong></p>
<blockquote>
<div><p>Convert the reflection to an <em>Affine</em> object.</p>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Augmented matrix of the reflection.</p>
</div></blockquote>
<p><strong>reflect(P)</strong></p>
<blockquote>
<div><p>An alias of <em>transform</em>.</p>
</div></blockquote>
<p><strong>reflect_circle(circ)</strong></p>
<blockquote>
<div><p>Reflect a circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>reflect_line(line)</strong></p>
<blockquote>
<div><p>Reflect a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform(P)</strong></p>
<blockquote>
<div><p>Transform a point by the refection.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>P</strong> – a point, <em>inf</em> allowed</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The image of <em>P</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform_circle(circ)</strong></p>
<blockquote>
<div><p>An alias of <em>reflect_circle</em>.</p>
</div></blockquote>
<p><strong>transform_line(line)</strong></p>
<blockquote>
<div><p>An alias of <em>reflect_line</em>.</p>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Rotation(center, theta, degrees=True)</strong></p>
<blockquote>
<div><p>A class for rotations. A rotation is given by its center and its
angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>center</strong> – a point</p></li>
<li><p><strong>theta</strong> – a number, the angle of the rotation</p></li>
<li><p><strong>degrees</strong> – Boolean, whether the angle is given in degrees</p></li>
</ul>
</dd>
</dl>
<p><strong>as_affine()</strong></p>
<blockquote>
<div><p>Convert the rotation to an <em>Affine</em> object.</p>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Augmented matrix of the rotation.</p>
</div></blockquote>
<p><strong>rotate(M)</strong></p>
<blockquote>
<div><p>Rotate a point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point or a matrix of points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point or a matrix of points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>rotate_circle(circ)</strong></p>
<blockquote>
<div><p>Rotate a circle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ</strong> – a <em>Circle</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>rotate_ellipse(ell)</strong></p>
<blockquote>
<div><p>Rotate an ellipse.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ell</strong> – an <em>Ellipse</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>rotate_line(line)</strong></p>
<blockquote>
<div><p>Rotate a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>line</strong> – a <em>Line</em> object</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Line</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>transform(M)</strong></p>
<blockquote>
<div><p>An alias of <em>rotate</em>.</p>
</div></blockquote>
<p><strong>transform_circle(circ)</strong></p>
<blockquote>
<div><p>An alias of <em>rotate_circle</em>.</p>
</div></blockquote>
<p><strong>transform_ellipse(ell)</strong></p>
<blockquote>
<div><p>An alias of <em>rotate_ellipse</em>.</p>
</div></blockquote>
<p><strong>transform_line(line)</strong></p>
<blockquote>
<div><p>An alias of <em>rotate_line</em>.</p>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.ScalingXY(center, sx, sy)</strong></p>
<blockquote>
<div><p>A class for axis-scalings. An axis-scaling is given by a center,
and  two scale factors <em>sx</em> and <em>sy</em>, one for the x-axis and one
for the y-axis.</p>
<p><strong>as_affine()</strong></p>
<blockquote>
<div><p>Converting to an <em>Affine</em> object.</p>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Get the augmented matrix of the axes-scaling.</p>
</div></blockquote>
<p><strong>transform(M)</strong></p>
<blockquote>
<div><p>Transform one or more points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point or a matrix of points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point or a matrix of points.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Shear(vertex, vector, ratio, angle,
degrees=True)</strong></p>
<blockquote>
<div><p>A class for shear transformations. A shear is given by a vertex,
two perpendicular vectors, and an angle.</p>
<dl class="field-list simple">
<dt class="field-odd">Example</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]);</span> <span class="n">ratio</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">angle</span> <span class="o">=</span> <span class="mi">45</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shear</span> <span class="o">=</span> <span class="n">Shear</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">ratio</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wt</span> <span class="o">=</span> <span class="n">ratio</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Q</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="n">w</span><span class="p">;</span> <span class="n">R</span> <span class="o">=</span> <span class="n">Q</span> <span class="o">+</span> <span class="n">wt</span><span class="p">;</span> <span class="n">S</span> <span class="o">=</span> <span class="n">P</span> <span class="o">+</span> <span class="n">wt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">P</span><span class="p">);</span> <span class="n">B</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">R</span><span class="p">);</span> <span class="n">D</span> <span class="o">=</span> <span class="n">shear</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">figure</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unit_square</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">P</span><span class="p">,</span><span class="n">Q</span><span class="p">,</span><span class="n">R</span><span class="p">,</span><span class="n">S</span><span class="p">],</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">unit_square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">Polygon</span><span class="p">([</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">,</span><span class="n">C</span><span class="p">,</span><span class="n">D</span><span class="p">],</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">axes</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p><strong>as_affine()</strong></p>
<blockquote>
<div><p>Convert the shear to an <em>Affine</em> object.</p>
</div></blockquote>
<p><strong>get3x3matrix()</strong></p>
<blockquote>
<div><p>Get the augmented matrix of the shear.</p>
</div></blockquote>
<p><strong>transform(M)</strong></p>
<blockquote>
<div><p>Transform one or more points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>M</strong> – a point or a matrix of points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point or a matrix of points.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>class planegeometry.geometry.Triangle(A, B, C)</strong></p>
<blockquote>
<div><p>Triangle class.</p>
<p>A triangle is initialized by its three vertices, some array-like
objects  of length two.</p>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">a</span></code></p>
<blockquote>
<div><p>Length of the side BC.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">angleA</span></code></p>
<blockquote>
<div><p>The angle at the vertex A in radians.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">angleB</span></code></p>
<blockquote>
<div><p>The angle at the vertex B in radians.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">angleC</span></code></p>
<blockquote>
<div><p>The angle at the vertex C in radians.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">b</span></code></p>
<blockquote>
<div><p>Length of the side AC.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">c</span></code></p>
<blockquote>
<div><p>Length of the side AB.</p>
</div></blockquote>
<p><strong>contains(M)</strong></p>
<blockquote>
<div><p>Check whether a point lies inside the reference triangle.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">edges</span></code></p>
<blockquote>
<div><p>Edge lengths of the triangle.</p>
</div></blockquote>
<p><strong>equal_detour_point()</strong></p>
<blockquote>
<div><p>Equal detour point of the triangle, also known as the X(176)
triangle center.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A pair, the equal detour point and the detour.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>excircles()</strong></p>
<blockquote>
<div><p>The excircles of the triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dictionary of three <em>Circle</em> objects.</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">flatness</span></code></p>
<blockquote>
<div><p>Flatness, a number between 0 and 1; a triangle is flat when its
flatness is 1.</p>
</div></blockquote>
<p><strong>incircle()</strong></p>
<blockquote>
<div><p>The incircle of the triangle.</p>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">is_acute</span></code></p>
<blockquote>
<div><p>Check whether the triangle is acute.</p>
</div></blockquote>
<p><strong>malfatti_circles()</strong></p>
<blockquote>
<div><p>The Malfatti circles of the triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Three circles and three tangency points.</p>
</dd>
</dl>
</div></blockquote>
<p><code class="docutils literal notranslate"><span class="pre">property</span> <span class="pre">orientation</span></code></p>
<blockquote>
<div><p>Orientation of the triangle; 1 for counterclockwise, -1 for
clockwise, 0 for collinear.</p>
</div></blockquote>
<p><strong>orthic_triangle()</strong></p>
<blockquote>
<div><p>Orthic triangle. Its vertices are the feet of the altitudes of
the reference triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A <em>Triangle</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>random_points(n_points, where=’in’)</strong></p>
<blockquote>
<div><p>Random points inside the triangle or on the boundary of the
triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_points</strong> – desired number of points</p></li>
<li><p><strong>where</strong> – either <em>“in”</em> or <em>“on”</em></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A matrix with <em>n_points</em> rows and two columns; each row is a
random point inside the triangle if <em>where=”in”</em> or on the
boundary of the triangle if <em>where=”on”</em>.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>steiner_ellipse()</strong></p>
<blockquote>
<div><p>The Steiner ellipse (or circumellipse) of the reference
triangle.  This is the ellipse passing through the three
vertices of the triangle  and centered at the centroid of the
triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>steiner_inellipse()</strong></p>
<blockquote>
<div><p>The Steiner inellipse (or midpoint ellipse) of the reference
triangle.  This is the ellipse tangent to the sides of the
triangle at their  midpoints, and centered at the centroid of
the triangle.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>An <em>Ellipse</em> object.</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p><strong>planegeometry.geometry.circleAB(A, B)</strong></p>
<blockquote>
<div><p>Circle with diameter AB.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>A**</strong>,****B** – two distinct points</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>planegeometry.geometry.intersection_circle_circle(circ1, circ2)</strong></p>
<blockquote>
<div><p>Intersection(s) of two circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ1**</strong>,****circ2** – <em>Circle</em> objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object if the two circles are equal, <em>None</em> if the
two circles do not intersect, a point if the two circles are
tangent, or a list of two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>planegeometry.geometry.intersection_circle_line(circ, line)</strong></p>
<blockquote>
<div><p>Intersection(s) of a circle and a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>circ</strong> – a <em>Circle</em> object</p></li>
<li><p><strong>line</strong> – a <em>Line</em> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em> if the intersection is empty, otherwise either one point
(the line is tangent to the circle) or a list of two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>planegeometry.geometry.intersection_ellipse_line(ell, line)</strong></p>
<blockquote>
<div><p>Intersection(s) of an ellipse and a line.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ell</strong> – an <em>Ellipse</em> object</p></li>
<li><p><strong>line</strong> – a <em>Line</em> object</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><em>None</em> if the intersection is empty, otherwise either one point
(the line is tangent to the ellipse) or a list of two points.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>planegeometry.geometry.mid_circles(circ1, circ2)</strong></p>
<blockquote>
<div><p>Return the mid-circle(s) of two circles. A mid-circle of two
circles is  a generalized circle (i.e. a circle or a line) such
that the Inversion.fro on  this circle swaps the two circles. The
case of a line appears only when  the two circles have equal radii.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ1**</strong>,****circ2** – <em>Circle</em> objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A <em>Circle</em> object, or a <em>Line</em> object, or a list of two such
objects.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>planegeometry.geometry.radical_center(circ1, circ2, circ3)</strong></p>
<blockquote>
<div><p>Radical center of three circles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circ1**</strong>,****circ2****,****circ3** – <em>Circle</em> objects</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A point, the radical center of the three circles.</p>
</dd>
</dl>
</div></blockquote>
<p><strong>planegeometry.geometry.unimodular_matrices(n)</strong></p>
<blockquote>
<div><p>Generates unimodular matrices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> – integer, the maximum size of entries of matrices, at
least 1</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>List of unimodular matrices.</p>
</dd>
</dl>
</div></blockquote>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">PyPlaneGeometry</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Stéphane Laurent.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>